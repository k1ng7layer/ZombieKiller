using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Ecs.Commands.Generator.Editor.Utils;
using Generator.Common;
using JCMG.EntitasRedux.Commands;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ecs.Commands.Generator.Editor
{
	public class CommandExtensionsGenerator
	{
		private const string CLASS_NAME = "CommandBufferExtensions";

		public GeneratedFile Generate(DirectoryInfo generationDirectory, string baseNamespace)
		{
			var allCommandTypes = AssemblyUtils.FindTypes(type => type.HasAttribute<CommandAttribute>());
			var file = GenerateFile(generationDirectory, baseNamespace, allCommandTypes);
			return file;
		}

		private GeneratedFile GenerateFile(
			DirectoryInfo generationDirectory,
			string namespaceStr,
			List<Type> commandTypes
		)
		{

			var @namespace = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(namespaceStr))
				.NormalizeWhitespace();

			var usingDirectives = new UsingDirectivesHashSet
			{
				SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(typeof(ICommandBuffer).Namespace))
					.NormalizeWhitespace(),
			};
			var methods = new List<MethodDeclarationSyntax>();

			foreach (var commandType in commandTypes)
			{
				var info = CreateCommandTemplate.GenerateTemplate(commandType);
				usingDirectives.AddRange(info.UsingDirectives);
				methods.Add(info.MethodDeclaration);
			}

			var classInfo = CreateClass(methods);
			@namespace = @namespace.AddMembers(classInfo);

			var cu = SyntaxFactory.CompilationUnit()
				.AddUsings(usingDirectives.ToArray());

			cu = cu.AddMembers(@namespace);

			var initialCode = cu
				.NormalizeWhitespace()
				.ToFullString();
			var autoPropRegex = new Regex(@"\s*\{\s*get;\s*set;\s*}\s");
			initialCode = autoPropRegex.Replace(initialCode, " { get; set; }");
			var code = GetComment();
			code += initialCode;
			code = AddRefs(code);
			
			var implFileInfo = GetImplFileInfo(generationDirectory);

			return new GeneratedFile(implFileInfo, code);
		}

		private static FileInfo GetImplFileInfo(DirectoryInfo directory)
		{
			var fileName = $"{CLASS_NAME}.cs";
			return new FileInfo(Path.Combine(directory.FullName, fileName));
		}

		private ClassDeclarationSyntax CreateClass(List<MethodDeclarationSyntax> methods)
		{
			var classDeclaration = SyntaxFactory.ClassDeclaration(CLASS_NAME);
			classDeclaration = classDeclaration
				.AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), 
					SyntaxFactory.Token(SyntaxKind.StaticKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword));

			classDeclaration = classDeclaration.AddMembers(methods.Cast<MemberDeclarationSyntax>().ToArray());
			return classDeclaration;
		}

		private string AddRefs(string code)
		{
			var res = "";
			using var reader = new StringReader(code);
			var line = string.Empty;
			do
			{
				line = reader.ReadLine();
				if (line != null && line.Contains("FLAG_CODE_GEN_"))
				{
					line = line.Replace("var FLAG_CODE_GEN_command", "ref var command")
						.Replace("FLAG_CODE_GEN_commandBuffer", "ref commandBuffer");
				}
				res += line + "\n";

			} while (line != null);

			return res;
		}
		
		private static string GetComment() 
			=> @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Commands Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
";
	}
}